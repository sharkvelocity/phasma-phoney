<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Phasma-Phoney</title>
  <style>
    body {
      background: black;
      color: white;
      font-family: sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow: hidden;
    }
    h1 {
      margin-top: 40px;
      font-size: 2.5em;
      color: cyan;
      text-shadow: 0 0 10px cyan;
    }
    button {
      background: #222;
      color: white;
      border: 1px solid #666;
      padding: 10px;
      margin: 5px;
      cursor: pointer;
    }
    #start-btn {
      font-size: 16px;
      margin-top: 20px;
    }
    .hidden {
      display: none;
    }
    #game-screen {
      display: flex;
      width: 100vw;
      height: 100vh;
      justify-content: space-between;
      padding: 10px;
    }
    #left-panel, #right-panel {
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 10px;
    }
    #center-panel {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
    }
    #narrator-box, #main-readout, #hud-status {
      background: #111;
      padding: 10px;
      margin: 5px;
      border: 1px solid #444;
      width: 90%;
    }
    #mini-map {
      border: 2px solid green;
      padding: 4px;
      height: 100px;
      width: 100px;
      text-align: center;
      font-size: 12px;
    }
    .orb {
      position: absolute;
      width: 6px;
      height: 6px;
      background: white;
      border-radius: 50%;
      opacity: 0;
      animation-name: drift, fade;
      animation-timing-function: linear, ease-in-out;
      animation-iteration-count: infinite;
      pointer-events: none;
    }
    @keyframes drift {
      0% { transform: translate(0, 0); }
      100% { transform: translate(var(--dx), var(--dy)); }
    }
    @keyframes fade {
      0%, 100% { opacity: 0; }
      50% { opacity: 0.8; }
    }
  </style>
</head>
<body>
  <h1>Phasma-Phoney</h1>
  <button id="start-btn">Start Investigation</button>
  <div id="game-screen" class="hidden">
    <div id="left-panel">
      <div id="option-buttons">
      <button id="journal-btn">Journal</button>
      <button id="guess-btn">Guess Ghost</button>
      <button id="item-btn">Use Item</button>
      <button id="van-btn">Return to Van</button>
    </div>
    <div id="center-panel">
      <div id="narrator-box">Welcome!</div>
      <div id="hud-status">Sanity: 100% XP: 0 Inventory: none</div>
      <div id="main-readout">Awaiting interaction...</div>
    </div>
    </div>
  </div>
  <div id="journal-screen" class="screen hidden" style="position:absolute;top:10%;left:10%;width:80%;background:#111;padding:12px;border:2px solid #666;z-index:999;">
    <h2>Investigation Journal</h2>
    <textarea id="journal-entry" placeholder="Write your notes here..." style="width:100%;height:120px;"></textarea>
    <br/>
    <button id="save-journal">Save</button>
    <button id="close-journal">Close</button>
  </div>

  <!-- INSERTED GAME LOGIC SCRIPTS START -->
<!-- 1. Utility + DOM setup -->
<script>
  // Floating orbs
  for (let i = 0; i < 10; i++) {
    const orb = document.createElement('div');
    orb.className = 'orb';
    orb.style.left = Math.random() * 100 + 'vw';
    orb.style.top = Math.random() * 100 + 'vh';
    const dx = (Math.random() - 0.5) * 200 + 'px';
    const dy = (Math.random() - 0.5) * 200 + 'px';
    orb.style.setProperty('--dx', dx);
    orb.style.setProperty('--dy', dy);
    const duration = 8 + Math.random() * 5;
    orb.style.animationDuration = `${duration}s, ${duration}s`;
    orb.style.animationDelay = `${Math.random() * 5}s, ${Math.random() * 5}s`;
    document.body.appendChild(orb);
  }

  // Text appenders
  function appendReadout(text) {
    const log = document.getElementById('main-readout');
    log.innerText += `\n${text}`;
    log.scrollTop = log.scrollHeight;
  }

  function displayNarratorText(text) {
    document.getElementById('narrator-box').innerText = text;
    appendReadout(text);
  }

  window.displayNarratorText = displayNarratorText;
  window.addToReadout = appendReadout;
</script>
  <!-- ğŸ§  MECHANICS SYSTEM (Full: Sanity, XP, Hunts, Cursed Items, Tarot) -->
<script>

  let sanity = 100;
  let ghostActivityLevel = 0;
  let currentHunt = false;
  let evidenceDiscovered = [];
  let xp = 0;
  let turn = 0;
  let cursedItemsUsed = 0;
  let lastAction = '';

  const tarotCards = [
    'ğŸƒ The Fool â€“ Nothing happens.',
    'ğŸª¦ The Hanged Man â€“ You feel your sanity drain rapidly.',
    'â˜€ï¸ The Sun â€“ You are filled with hope. Sanity fully restored!',
    'ğŸŒ‘ The Moon â€“ Your mind fractures. Sanity drops to 0!',
    'ğŸ§™ The Hermit â€“ The ghost is temporarily trapped.',
    'ğŸ¡ The Wheel of Fortune â€“ Sanity shifts unpredictably.',
    'ğŸ’€ Death â€“ A hunt begins instantly!',
    'ğŸ‘¹ The Devil â€“ The ghost manifests nearby.',
    'ğŸ—¼ The Tower â€“ A crash rings out. The ghost moves to your room.',
    'ğŸ‘¼ The High Priestess â€“ You sense a protective spirit.'
  ];

  function getSanity() {
    return sanity;
  }

  function adjustSanity(amount) {
    sanity = Math.max(0, Math.min(100, sanity + amount));
  }

  function getXP() {
    return xp;
  }

  function addXP(amount) {
    xp += amount;
  }

  function isHunting() {
    return currentHunt;
  }

  function triggerHunt() {
    currentHunt = true;
    ghostActivityLevel = 10;
    adjustSanity(-25);
    lastAction = 'hunt';
    return 'ğŸš¨ Hunt started! You hear footsteps racing toward you!';
  }

  function endHunt() {
    currentHunt = false;
    ghostActivityLevel = 0;
    return 'ğŸ’¨ The hunt ends. Silence returns.';
  }

  function getGhostActivity() {
    return ghostActivityLevel;
  }

  function performGhostAction() {
    turn++;
    const roll = Math.random();
    if (roll < 0.1) {
      return triggerHunt();
    } else if (roll < 0.3) {
      ghostActivityLevel = 6;
      adjustSanity(-10);
      lastAction = 'major activity';
      return 'âš¡ Flickering lights. The air feels heavy.';
    } else if (roll < 0.6) {
      ghostActivityLevel = 3;
      lastAction = 'minor activity';
      return 'ğŸ‘£ Footsteps echo somewhere nearby.';
    } else {
      ghostActivityLevel = 1;
      lastAction = 'idle';
      return 'ğŸ•¯ï¸ Nothing yet. Stay vigilant.';
    }
  }

  function discoverEvidence(evidence) {
    if (!evidenceDiscovered.includes(evidence)) {
      evidenceDiscovered.push(evidence);
      xp += 10;
      return `ğŸ” You recorded new evidence: ${evidence}`;
    }
    return `ğŸ“ Already documented: ${evidence}`;
  }

  function getEvidence() {
    return evidenceDiscovered;
  }

  function useCursedItem(name) {
    cursedItemsUsed++;
    adjustSanity(-20);
    let result = `ğŸ”® You use the ${name}. Reality ripples through the air...`;

    if (name.toLowerCase().includes('tarot')) {
      const card = drawTarotCard();
      result += `\n${card}`;
    }

    lastAction = 'cursed item';
    return result;
  }

  function drawTarotCard() {
    const card = tarotCards[Math.floor(Math.random() * tarotCards.length)];

    if (card.includes('sanity drain')) adjustSanity(-30);
    if (card.includes('fully restored')) adjustSanity(100 - sanity);
    if (card.includes('drops to 0')) sanity = 0;
    if (card.includes('hunt')) triggerHunt();
    if (card.includes('manifest')) ghostActivityLevel = 7;
    if (card.includes('moves to your room')) ghostActivityLevel = 8;

    return `ğŸƒ Tarot card drawn: ${card}`;
  }

  function getStats() {
    return {
      sanity,
      xp,
      evidenceDiscovered: [...evidenceDiscovered],
      cursedItemsUsed,
      turns: turn,
      ghostActivityLevel,
      lastAction
    };
  }

  function resetStats() {
    sanity = 100;
    ghostActivityLevel = 0;
    currentHunt = false;
    evidenceDiscovered = [];
    xp = 0;
    cursedItemsUsed = 0;
    turn = 0;
    lastAction = '';
  }

  // Global bindings
  window.getSanity = getSanity;
  window.adjustSanity = adjustSanity;
  window.getXP = getXP;
  window.addXP = addXP;
  window.isHunting = isHunting;
  window.triggerHunt = triggerHunt;
  window.endHunt = endHunt;
  window.getGhostActivity = getGhostActivity;
  window.performGhostAction = performGhostAction;
  window.discoverEvidence = discoverEvidence;
  window.getEvidence = getEvidence;
  window.useCursedItem = useCursedItem;
  window.getStats = getStats;
  window.resetStats = resetStats;
</script>
<!-- ğŸ“¦ INVENTORY SYSTEM -->
<script>
  const inventory = {}; // Tracks items and counts
 const allItems = [
  'Smudge Stick', 'Candle', 'EMF Reader', 'Spirit Box',
  'Crucifix', 'UV Light', 'Thermometer',
  'Parabolic Mic', 'Proximity Sensor', 'Camera', 'Salt'
];

let selectedLoadout = [];

function showLoadoutMenu() {
  const container = document.getElementById('loadout-options');
  if (!container) return;

  container.innerHTML = '';
  selectedLoadout = [];

  allItems.forEach(item => {
    const btn = document.createElement('button');
    btn.innerText = item;
    btn.style.margin = '4px';
    btn.onclick = () => toggleLoadoutItem(item, btn);
    container.appendChild(btn);
  });

  document.getElementById('loadout-selected').innerText = `Selected: 0`;
}

function toggleLoadoutItem(item, btn) {
  if (selectedLoadout.includes(item)) {
    selectedLoadout = selectedLoadout.filter(i => i !== item);
    btn.style.backgroundColor = '';
  } else if (selectedLoadout.length < 3) {
    selectedLoadout.push(item);
    btn.style.backgroundColor = 'green';
  }
  document.getElementById('loadout-selected').innerText = `Selected: ${selectedLoadout.length}`;
}

document.addEventListener('DOMContentLoaded', () => {
  document.getElementById('confirm-loadout').onclick = () => {
    if (selectedLoadout.length === 0) {
      alert("Select at least one item.");
      return;
    }

    selectedLoadout.forEach(item => addItemToInventory(item));
    document.getElementById('loadout-screen').style.display = 'none';
    document.getElementById('game-screen').classList.remove('hidden');
    startGame();
  };
});
  const itemData = {
    'Smudge Stick': { consumable: true },
    'Candle': { consumable: false },
    'EMF Reader': { consumable: false },
    'Spirit Box': { consumable: false },
    'Crucifix': { consumable: false },
    'UV Light': { consumable: false },
    'Thermometer': { consumable: false },
    'Parabolic Mic': { consumable: false },
    'Proximity Sensor': { consumable: false },
    'Camera': { consumable: true },
    'Salt': { consumable: true }
  };

  const ghostReactions = {
    'Smudge Stick': ['Spirit', 'Revenant', 'Yurei', 'Demon', 'Moroi'],
    'Salt': ['Wraith', 'The Mimic'],
    'Candle': ['Mare', 'Onryo', 'Succubus'],
    'Crucifix': ['Demon', 'Revenant', 'Deogen'],
    'Parabolic Mic': ['Myling', 'Banshee'],
    'UV Light': ['Obake', 'Hantu'],
    'EMF Reader': ['Jinn', 'Oni', 'The Twins'],
    'Thermometer': ['Hantu', 'Shade', 'Onryo'],
    'Proximity Sensor': ['Deogen'],
    'Voice': ['Yokai', 'Moroi'],
    'Camera': ['Phantom', 'Banshee']
  };

  function addItemToInventory(item) {
    const total = Object.values(inventory).reduce((sum, count) => sum + count, 0);
    if (total >= 3) {
      displayNarratorText(`âŒ You can only carry 3 items.`);
      return false;
    }
    if (!inventory[item]) {
      inventory[item] = 1;
      displayNarratorText(`ğŸ’ Added ${item}.`);
    } else {
      displayNarratorText(`ğŸ§³ Already carrying a ${item}.`);
    }
    updateHUD();
    return true;
  }

  function getInventory() {
    return Object.entries(inventory)
      .map(([item, count]) => count > 1 ? `${item} x${count}` : item);
  }

  function useItem(item, room, ghostType) {
    if (!inventory[item]) return `âŒ You donâ€™t have a ${item}.`;

    if (itemData[item]?.consumable) {
      inventory[item]--;
      if (inventory[item] <= 0) delete inventory[item];
    }

    updateHUD();

    let result = '';
    switch (item.toLowerCase()) {
      case 'candle':
        result = `ğŸ•¯ï¸ You light the candle. A gentle glow fills the ${room}.`;
        break;
      case 'emf reader':
        const emf = Math.random() < 0.4 ? 5 : 2;
        result = `ğŸ“Ÿ EMF Reader shows a level ${emf} reading.`;
        if (emf === 5) result += '\n' + discoverEvidence('EMF Level 5');
        break;
      case 'spirit box':
        const reply = Math.random() < 0.3;
        result = reply
          ? `ğŸ“» A static-laced voice whispers back.\n${discoverEvidence('Spirit Box')}`
          : `ğŸ“» Static only. No response.`;
        break;
      case 'smudge stick':
        result = `ğŸ’¨ You burn the smudge stick. The air clears in the ${room}.`;
        adjustSanity(+10);
        break;
      case 'crucifix':
        const safe = Math.random() < 0.5;
        result = safe
          ? `âœï¸ The Crucifix warms faintly in your hand.`
          : `âœï¸ Nothing happens.`;
        break;
      case 'mirror':
        result = `ğŸª You glimpse a shadowy ${ghostType} figure.`;
        adjustSanity(-15);
        break;
      case 'tarot cards':
        result = useCursedItem('Tarot Cards');
        break;
      default:
        result = `ğŸ› ï¸ You try to use the ${item}, but nothing happens.`;
    }

    if (ghostReactions[item]?.includes(ghostType)) {
      result += `\nğŸŒ€ The ${item} reacts strongly to the ${ghostType}!`;
    }

    return result;
  }

  function updateHUD() {
    const status = document.getElementById('hud-status');
    const inventoryList = getInventory().join(', ') || 'none';
    status.innerText = `Sanity: ${getSanity()}% | XP: ${getXP()} | Inventory: ${inventoryList}`;
  }

  // Expose globally
  window.addItemToInventory = addItemToInventory;
  window.getInventory = getInventory;
  window.useItem = useItem;
  window.updateHUD = updateHUD;
</script>
<!-- ğŸ—ºï¸ MAP SYSTEM -->
<script>
  const rooms = [
    'Foyer', 'Living Room', 'Kitchen', 'Dining Room',
    'Bathroom', 'Basement', 'Bedroom', 'Garage'
  ];

  let currentRoom = 'Foyer';

  const roomMap = {
    'Foyer':        { North: 'Living Room', East: 'Garage', South: 'Basement', West: null },
    'Living Room':  { South: 'Foyer', East: 'Kitchen', West: 'Dining Room' },
    'Kitchen':      { West: 'Living Room' },
    'Dining Room':  { East: 'Living Room' },
    'Bathroom':     { North: 'Bedroom' },
    'Bedroom':      { South: 'Bathroom' },
    'Garage':       { West: 'Foyer' },
    'Basement':     { North: 'Foyer' }
  };

  function initializeMap() {
    currentRoom = 'Foyer';
    displayNarratorText(`ğŸ“ You are in the ${currentRoom}.`);
    updateMiniMap();
  }

  function movePlayer(direction) {
    const available = roomMap[currentRoom] || {};
    const destination = available[direction];

    if (destination) {
      currentRoom = destination;
      adjustSanity(-2); // Lose sanity when moving
      updateMiniMap();
      return `ğŸšª You move ${direction} to the ${destination}.`;
    } else {
      return `âŒ You can't move ${direction} from the ${currentRoom}.`;
    }
  }

  function getCurrentRoom() {
    return currentRoom;
  }

  function updateMiniMap() {
    const mapDisplay = document.getElementById('mini-map');
    if (mapDisplay) mapDisplay.innerText = `Room: ${currentRoom}`;
  }

  // Global bindings
  window.initializeMap = initializeMap;
  window.movePlayer = movePlayer;
  window.getCurrentRoom = getCurrentRoom;
  window.updateMiniMap = updateMiniMap;
</script>
<!-- ğŸ‘» GHOST LOGIC DISPATCHER (Final Version) -->
<script>
  const ghostList = [
    { type: 'Spirit', evidence: ['EMF 5', 'Ghost Writing', 'Spirit Box'], preferred: ['Smudge Stick', 'Book'] },
    { type: 'Wraith', evidence: ['DOTS', 'EMF 5', 'Spirit Box'], preferred: ['Salt', 'UV Light'] },
    { type: 'Phantom', evidence: ['DOTS', 'Fingerprints', 'Spirit Box'], preferred: ['Camera'] },
    { type: 'Poltergeist', evidence: ['Ghost Writing', 'Spirit Box', 'Fingerprints'], preferred: ['Sound Sensor'] },
    { type: 'Banshee', evidence: ['DOTS', 'Fingerprints', 'Orb'], preferred: ['Parabolic Mic', 'Crucifix'] },
    { type: 'Jinn', evidence: ['EMF 5', 'Fingerprints', 'Freezing'], preferred: ['Breaker Off', 'EMF Reader'] },
    { type: 'Mare', evidence: ['Orb', 'Ghost Writing', 'Spirit Box'], preferred: ['Candle', 'Dark'] },
    { type: 'Revenant', evidence: ['Orb', 'Ghost Writing', 'Freezing'], preferred: ['Smudge Stick', 'Crucifix'] },
    { type: 'Shade', evidence: ['EMF 5', 'Ghost Writing', 'Freezing'], preferred: ['Thermometer'] },
    { type: 'Demon', evidence: ['Ghost Writing', 'Freezing', 'Fingerprints'], preferred: ['Crucifix'] },
    { type: 'Yurei', evidence: ['DOTS', 'Orb', 'Freezing'], preferred: ['Smudge Stick'] },
    { type: 'Oni', evidence: ['DOTS', 'EMF 5', 'Freezing'], preferred: ['EMF Reader'] },
    { type: 'Hantu', evidence: ['Fingerprints', 'Orb', 'Freezing'], preferred: ['Thermometer'] },
    { type: 'Yokai', evidence: ['DOTS', 'Orb', 'Spirit Box'], preferred: ['Voice'] },
    { type: 'Goryo', evidence: ['DOTS', 'EMF 5', 'Fingerprints'], preferred: ['Video Camera'] },
    { type: 'Myling', evidence: ['EMF 5', 'Ghost Writing', 'Fingerprints'], preferred: ['Parabolic Mic'] },
    { type: 'Onryo', evidence: ['Orb', 'Freezing', 'Spirit Box'], preferred: ['Candle'] },
    { type: 'The Twins', evidence: ['EMF 5', 'Freezing', 'Spirit Box'], preferred: ['Motion Sensor'] },
    { type: 'Raiju', evidence: ['DOTS', 'EMF 5', 'Orb'], preferred: ['Electronics'] },
    { type: 'Obake', evidence: ['EMF 5', 'Orb', 'Fingerprints'], preferred: ['UV Light'] },
    { type: 'The Mimic', evidence: ['Freezing', 'Fingerprints', 'Spirit Box'], preferred: ['Salt'] },
    { type: 'Moroi', evidence: ['Freezing', 'Ghost Writing', 'Spirit Box'], preferred: ['Smudge Stick'] },
    { type: 'Deogen', evidence: ['DOTS', 'Ghost Writing', 'Spirit Box'], preferred: ['Proximity Sensor'] },
    { type: 'Thaye', evidence: ['DOTS', 'Orb', 'Ghost Writing'], preferred: ['Timer'] },
    { type: 'Succubus', evidence: ['Spirit Box', 'Orb', 'Freezing'], preferred: ['Mirror', 'Candle'] }
  ];

  let currentGhost = null;

  function getRandomGhost() {
    const g = ghostList[Math.floor(Math.random() * ghostList.length)];
    return { ...g };
  }

  function initializeGhost(ghost) {
    currentGhost = {
      ...ghost,
      behavior: generateGhostBehavior(ghost.type)
    };
  }

  function getCurrentGhost() {
    return currentGhost;
  }

  function performBehavior(room) {
    if (!currentGhost || !currentGhost.behavior) return "Nothing happens.";
    return currentGhost.behavior(room);
  }

  function generateGhostBehavior(type) {
    const base = [
      (room) => `You feel watched in the ${room}.`,
      (room) => `A faint breeze brushes past in the ${room}.`,
      (room) => `The lights flicker slightly in the ${room}.`,
      (room) => `You hear a soft whisper in the ${room}.`,
      (room) => `A sense of unease fills the ${room}.`
    ];

    const special = {
      'Poltergeist': [
        (room) => `Objects rattle violently in the ${room}.`,
        (room) => `Drawers slam in the ${room}.`
      ],
      'Demon': [
        (room) => `A growl echoes from the shadows of the ${room}.`,
        (room) => `You feel dread pressing down in the ${room}.`
      ],
      'Succubus': [
        (room) => `A sultry voice whispers in the ${room}.`,
        (room) => `The air feels heated and heavy in the ${room}.`
      ],
      'The Twins': [
        (room) => `You hear double footsteps in the ${room}.`,
        (room) => `Two presences are sensed in the ${room}.`
      ],
      'The Mimic': [
        (room) => `The behavior mimics something you've seen before in the ${room}.`,
        (room) => `Unusual activityâ€”could be a decoy in the ${room}.`
      ]
    };

    const behaviorSet = [...base, ...(special[type] || [])];
    return (room) => {
      const act = behaviorSet[Math.floor(Math.random() * behaviorSet.length)];
      return act(room);
    };
  }

  // Expose all
  window.getRandomGhost = getRandomGhost;
  window.initializeGhost = initializeGhost;
  window.performBehavior = performBehavior;
  window.getCurrentGhost = getCurrentGhost;
</script>
  <!-- ğŸ““ JOURNAL SYSTEM -->
<script>
  let journalNotes = '';

  function initializeJournal() {
    const journalInput = document.getElementById('journal-entry');
    if (journalInput) {
      journalInput.value = journalNotes;
    }
  }

  function updateNotes(text) {
    journalNotes = text;
    displayNarratorText("ğŸ“ Notes updated in your journal.");
  }

  // Global exposure
  window.initializeJournal = initializeJournal;
  window.updateNotes = updateNotes;
</script>
  <!-- ğŸ® GAME LOGIC -->
<script>
  let ghost = null;

function startGame() {
  resetStats();
  const selected = getRandomGhost();
  ghost = selected;
  initializeGhost(selected);
  initializeMap(); // âœ… THIS sets currentRoom = 'Foyer' and displays it
  updateHUD();
  initializeJournal();
  displayNarratorText(`ğŸ•µï¸ Investigation started...`);
  renderOptions();
}

  function renderOptions() {
    const container = document.getElementById('option-buttons');
    container.innerHTML = '';

    const buttons = [
      { label: '1. Investigate', action: investigate },
      { label: '2. Use Item', action: useItemMenu },
      { label: '3. Move', action: moveMenu },
      { label: '4. Guess Ghost', action: guessMenu },
    ];

    buttons.forEach(({ label, action }) => {
      const btn = document.createElement('button');
      btn.innerText = label;
      btn.onclick = action;
      container.appendChild(btn);
    });
  }

  function investigate() {
    const text = performBehavior(getCurrentRoom());
    adjustSanity(-5);
    displayNarratorText(text);
    updateHUD();
  }

  function useItemMenu() {
    const container = document.getElementById('option-buttons');
    container.innerHTML = '';

    const items = getInventory();
    if (!items.length) {
      displayNarratorText("ğŸ§³ You have no items.");
      renderOptions();
      return;
    }

    items.forEach((item, i) => {
      const btn = document.createElement('button');
      btn.innerText = `${i + 1}. Use ${item}`;
      btn.onclick = () => {
        const result = useItem(item, getCurrentRoom(), ghost?.type || "Unknown");
        displayNarratorText(result);
        updateHUD();
        renderOptions();
      };
      container.appendChild(btn);
    });

    const back = document.createElement('button');
    back.innerText = 'Back';
    back.onclick = renderOptions;
    container.appendChild(back);
  }

  function moveMenu() {
    const container = document.getElementById('option-buttons');
    container.innerHTML = '';

    ['North', 'East', 'South', 'West'].forEach((dir) => {
      const btn = document.createElement('button');
      btn.innerText = `Go ${dir}`;
      btn.onclick = () => {
        const result = movePlayer(dir);
        displayNarratorText(result);
        updateHUD();
        renderOptions();
      };
      container.appendChild(btn);
    });

    const back = document.createElement('button');
    back.innerText = 'Back';
    back.onclick = renderOptions;
    container.appendChild(back);
  }

  function guessMenu() {
    const container = document.getElementById('option-buttons');
    container.innerHTML = '';

    const guesses = [
      'Spirit', 'Wraith', 'Phantom', 'Poltergeist', 'Banshee',
      'Jinn', 'Mare', 'Revenant', 'Shade', 'Demon',
      'Yurei', 'Oni', 'Hantu', 'Yokai', 'Goryo',
      'Myling', 'Onryo', 'The Twins', 'Raiju', 'Obake',
      'The Mimic', 'Moroi', 'Deogen', 'Thaye', 'Succubus'
    ];

    const actualGhost = getCurrentGhost();
    const ghostType = actualGhost?.type || "Unknown";

    guesses.forEach((type) => {
      const btn = document.createElement('button');
      btn.innerText = type;
      btn.onclick = () => {
        if (ghostType === type) {
          displayNarratorText(`âœ… Correct! It was a ${type}. You gain 200 XP.`);
          addXP(200);
        } else {
          displayNarratorText(`ğŸ’€ Wrong! It was a ${ghostType}.`);
          adjustSanity(-50);
        }
        updateHUD();
        renderOptions();
      };
      container.appendChild(btn);
    });

    const back = document.createElement('button');
    back.innerText = 'Back';
    back.onclick = renderOptions;
    container.appendChild(back);
  }

  function endInvestigation() {
    const remaining = getInventory();
    const used = selectedLoadout.filter(item => !remaining.includes(item));

    displayNarratorText(
      `ğŸš You return to the van.\n\nğŸ“¦ Remaining Items: ${remaining.length ? remaining.join(', ') : 'None'}\nğŸ—‘ï¸ Used Items: ${used.length ? used.join(', ') : 'None'}\n\nFinal Sanity: ${getSanity()}% | XP: ${getXP()}`
    );

    document.getElementById('option-buttons').innerHTML = '';
  }

  // Global bind
  window.startGame = startGame;
</script>
<!-- âš™ï¸ DOMContentLoaded Wiring -->
<script>
const vanScreen = document.getElementById('van-loadout-screen');
const vanItemsContainer = document.getElementById('van-items');
const vanWarning = document.getElementById('van-warning');

vanBtn.onclick = () => {
  vanItemsContainer.innerHTML = '';
  vanWarning.innerText = '';
  const totalItems = Object.values(inventory).reduce((sum, count) => sum + count, 0);

  allItems.forEach(item => {
    const btn = document.createElement('button');
    btn.innerText = item;
    btn.onclick = () => {
      if (inventory[item]) {
        delete inventory[item];
        displayNarratorText(`âŒ Removed ${item} from your loadout.`);
      } else if (totalItems < 3) {
        addItemToInventory(item);
      } else {
        vanWarning.innerText = 'âš ï¸ You can only carry 3 items total.';
        return;
      }

      updateHUD();
      vanBtn.click(); // re-render van menu
    };
    vanItemsContainer.appendChild(btn);
  });

  vanScreen.style.display = 'block';
};

document.getElementById('close-van').onclick = () => {
  vanScreen.style.display = 'none';
};
  <script>
  window.addEventListener('DOMContentLoaded', () => {
    const startBtn = document.getElementById('start-btn');
    const gameScreen = document.getElementById('game-screen');
    const journalBtn = document.getElementById('journal-btn');
    const guessBtn = document.getElementById('guess-btn');
    const itemBtn = document.getElementById('item-btn');
    const vanBtn = document.getElementById('van-btn');
    const journalScreen = document.getElementById('journal-screen');
    document.getElementById('back-btn').onclick = () => {
    document.getElementById('loadout-screen').style.display = 'none';
    document.getElementById('start-btn').style.display = 'inline-block';
};
    startBtn.onclick = () => {
      document.getElementById('start-btn').style.display = 'none';
      gameScreen.classList.add('hidden');               // Ensure game UI is hidden
      document.getElementById('loadout-screen').style.display = 'block';
      showLoadoutMenu();                                // âœ… Populate buttons now
    };

    // Journal buttons
    journalBtn.onclick = () => {
      journalScreen.classList.toggle('hidden');
    };

    document.getElementById('close-journal').onclick = () => {
      journalScreen.classList.add('hidden');
    };

    document.getElementById('save-journal').onclick = () => {
      const note = document.getElementById('journal-entry').value;
      updateNotes(note);
    };

    // UI action buttons
    guessBtn.onclick = () => guessMenu();
    itemBtn.onclick = () => useItemMenu();
    vanBtn.onclick = () => endInvestigation();
  });
</script>
  <!-- ğŸ” Turn System + Behavior Triggers -->
<script>
  function tickTurn() {
    const activity = performGhostAction();
    displayNarratorText(activity);

    // Passive evidence reveal
    if (Math.random() < 0.15) {
      const passive = ['Ghost Orbs', 'Fingerprints', 'Ghost Writing'];
      const revealed = passive[Math.floor(Math.random() * passive.length)];
      displayNarratorText(`ğŸ‘» You notice a clue: ${revealed}.`);
      discoverEvidence(revealed);
    }

    // Optional hunt trigger if sanity is very low
    if (getSanity() <= 15 && Math.random() < 0.3) {
      const huntMsg = triggerHunt();
      displayNarratorText(huntMsg);
    }

    updateHUD();
  }

  // Modify investigate to include turn tick
  const oldInvestigate = investigate;
  investigate = function () {
    oldInvestigate();
    tickTurn();
  };

  // Modify movement to include turn tick
  const oldMovePlayer = movePlayer;
  movePlayer = function (dir) {
    const result = oldMovePlayer(dir);
    tickTurn();
    return result;
  };

  // Modify useItemMenu to include tick after usage
  const oldUseItem = useItem;
  useItem = function (item, room, ghostType) {
    const result = oldUseItem(item, room, ghostType);
    tickTurn();
    return result;
  };

  window.tickTurn = tickTurn;
</script>
  <!-- This setup is clean and ready -->
<div id="van-loadout-screen" style="display:none; position:absolute; top:10%; left:10%; width:80%; background:#111; padding:12px; border:2px solid #666; z-index:999;">
  <h2>Van Inventory</h2>
  <p>Select items to add/swap (max 3 total carried)</p>
  <div id="van-items" style="display: flex; flex-wrap: wrap; gap: 10px;"></div>
  <p id="van-warning" style="color: red;"></p>
  <button id="close-van">Back to Investigation</button>
</div>
<div id="loadout-screen" style="display:none; position:absolute; top:10%; left:10%; width:80%; background:#111; padding:12px; border:2px solid #666; z-index:999;">
  <h2>Select Your Loadout (Max 3 items)</h2>
  <div id="loadout-options" style="display: flex; flex-wrap: wrap; gap: 10px;"></div>
  <p id="loadout-selected">Selected: 0</p>
  <button id="confirm-loadout">Confirm</button>
  <button id="back-btn">Back</button>  
</div>
</body>
</html>
