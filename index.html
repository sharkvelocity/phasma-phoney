    <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ghost Orb Capture</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: black;
      font-family: monospace;
      cursor: none;
    }

    .layer {
      position: fixed;
      top: 0;
      left: 0;
      width: 120vw;
      height: 120vh;
      background-size: cover;
      background-position: center;
      z-index: 0;
      transition: transform 0.1s linear;
    }

    #layer-back {
      background-image: url('https://i.imgur.com/z0a6H0n.jpg');
      z-index: 1;
    }

    #layer-mid {
      background-image: url('https://i.imgur.com/YCVwB91.png');
      z-index: 2;
    }

    #layer-front {
      background-image: url('https://i.imgur.com/zKMkqOS.png');
      z-index: 3;
    }

    .orb {
      position: fixed;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      pointer-events: none;
      opacity: 0;
      z-index: 5;
      transition: opacity 0.2s;
    }

    .regular-orb {
      background: radial-gradient(circle, rgba(255,255,255,0.8), transparent 70%);
      animation: float 4s infinite ease-in-out alternate;
    }

    .special-orb {
      background: radial-gradient(circle, rgba(0, 100, 255, 0.8), transparent 60%);
      animation: floatSpecial 1.2s infinite ease-in-out alternate;
    }

    @keyframes float {
      0% { transform: translateY(0px) scale(1); }
      100% { transform: translateY(-15px) scale(1.1); }
    }

    @keyframes floatSpecial {
      0% { transform: translateY(0px) scale(1); opacity: 1; }
      100% { transform: translateY(-20px) scale(1.3); opacity: 0.2; }
    }

    #lens {
      position: fixed;
      top: 0; left: 0;
      border-radius: 50%;
      pointer-events: none;
      z-index: 6;
      backdrop-filter: brightness(1.4) contrast(1.4);
      mix-blend-mode: screen;
      box-shadow: 0 0 30px 10px rgba(0,255,0,0.3);
      transition: width 0.3s, height 0.3s, filter 0.2s;
    }

    .vision-night { filter: hue-rotate(90deg) grayscale(0.1); }
    .vision-heat { filter: hue-rotate(270deg) saturate(2); }

    #lens-pointer {
      position: fixed;
      width: 20px;
      height: 20px;
      background: rgba(255,255,255,0.2);
      border: 2px solid lime;
      border-radius: 50%;
      z-index: 7;
      pointer-events: none;
    }

    #controls {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 10;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .btn {
      background: rgba(0,0,0,0.7);
      color: lime;
      border: 1px solid lime;
      padding: 5px 10px;
      cursor: pointer;
      font-size: 14px;
    }
#zoom-hud, #score-hud, #flip-clock {
      position: fixed;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid lime;
      color: lime;
      padding: 4px 10px;
      font-size: 14px;
      z-index: 10;
    }

    #zoom-hud { bottom: 10px; right: 10px; }
    #score-hud { bottom: 10px; left: 10px; }

    #flip-clock {
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 28px;
      font-weight: bold;
      background: rgba(0,0,0,0.4);
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      display: flex;
      gap: 4px;
    }

    .digit {
      background: rgba(0,0,0,0.6);
      padding: 4px 6px;
      border: 1px solid lime;
      border-radius: 3px;
      box-shadow: 0 0 4px lime;
      animation: flip 0.4s ease-in-out;
    }

    @keyframes flip {
      0% { transform: rotateX(90deg); opacity: 0; }
      100% { transform: rotateX(0deg); opacity: 1; }
    }

    #flash {
      position: fixed;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      background: white;
      opacity: 0;
      z-index: 20;
      pointer-events: none;
    }

    .flash-active {
      animation: flashOut 0.3s ease forwards;
    }

    @keyframes flashOut {
      0% { opacity: 1; }
      100% { opacity: 0; }
    }

    #scan-text {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: lime;
      font-size: 32px;
      opacity: 0;
      z-index: 21;
      pointer-events: none;
    }

    .scan-show {
      animation: scanBlink 0.5s ease-in-out forwards;
    }

    @keyframes scanBlink {
      0% { opacity: 1; }
      100% { opacity: 0; }
    }

    #game-over {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.85);
      color: white;
      z-index: 30;
      font-size: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      text-align: center;
      animation: fadeIn 1s ease-in-out forwards;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    #final-score {
      margin-top: 10px;
      font-size: 20px;
      color: lime;
    }

    #orbs-counted {
      margin-top: 5px;
      font-size: 18px;
    }
  </style>
</head>
<body>

<!-- Forest Layers -->
<div id="layer-back" class="layer"></div>
<div id="layer-mid" class="layer"></div>
<div id="layer-front" class="layer"></div>

<!-- Orb Container -->
<div id="orbs"></div>

<!-- Lens View -->
<div id="lens" class="vision-night"></div>
<div id="lens-pointer"></div>

<!-- HUD -->
<div id="controls">
  <button class="btn" onclick="togglePower()">Power</button>
  <button class="btn" onclick="toggleVision()">Toggle Vision</button>
</div>

<div id="zoom-hud">Zoom: 1x</div>
<div id="score-hud">Score: 0</div>

<!-- Flip Clock -->
<div id="flip-clock">
  <div class="digit" id="min-ten">0</div>
  <div class="digit" id="min-one">6</div>
  <div class="digit">:</div>
  <div class="digit" id="sec-ten">0</div>
  <div class="digit" id="sec-one">0</div>
</div>

<!-- Effects -->
<div id="flash"></div>
<div id="scan-text">SCAN</div>

<!-- Game Over -->
<div id="game-over">
  <div id="end-title">⏱️ Time's up!</div>
  <div id="final-score"></div>
  <div id="orbs-counted"></div>
</div>

<!-- Base64 Audio -->
<audio id="tick-sound" preload="auto">
  <source src="data:audio/mp3;base64,//uQxAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAACcQCA..." type="audio/mp3" />
</audio>
<audio id="heartbeat-sound" preload="auto">
  <source src="data:audio/mp3;base64,//uQxAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAACcQCA..." type="audio/mp3" />
</audio>
<script>
let isOn = false, currentVision = 'night';
let zoomLevel = 1, zoomIndex = 0;
const zoomSteps = [1, 1.5, 2, 2.5, 3];
let score = 0, orbsCaptured = 0, timeLeft = 60, timerStarted = false;
let gameInterval, lastTap = 0;
let ticking = false, heartbeat = false;

const lens = document.getElementById('lens');
const pointer = document.getElementById('lens-pointer');
const zoomHud = document.getElementById('zoom-hud');
const scoreHud = document.getElementById('score-hud');
const tickSound = document.getElementById('tick-sound');
const heartbeatSound = document.getElementById('heartbeat-sound');

const flipMinTen = document.getElementById('min-ten');
const flipMinOne = document.getElementById('min-one');
const flipSecTen = document.getElementById('sec-ten');
const flipSecOne = document.getElementById('sec-one');

function togglePower() {
  isOn = !isOn;
  lens.style.display = isOn ? 'block' : 'none';
  pointer.style.display = isOn ? 'block' : 'none';
  zoomHud.style.display = isOn ? 'block' : 'none';
  scoreHud.style.display = isOn ? 'block' : 'none';
  if (isOn && !timerStarted) startTimer();
}

function toggleVision() {
  if (!isOn) return;
  currentVision = (currentVision === 'night') ? 'heat' : 'night';
  lens.classList.toggle('vision-night', currentVision === 'night');
  lens.classList.toggle('vision-heat', currentVision === 'heat');
  updateOrbsVisibility();
}

function updateZoomVisual() {
  zoomHud.textContent = `Zoom: ${zoomLevel.toFixed(1)}x`;
  const lensSize = 200 + (zoomLevel - 1) * 100;
  lens.style.width = `${lensSize}px`;
  lens.style.height = `${lensSize}px`;
}

function moveLens(x, y) {
  if (!isOn) return;
  const lensSize = parseFloat(lens.style.width || "200px");
  const half = lensSize / 2;
  lens.style.transform = `translate(${x - half}px, ${y - half}px)`;
  pointer.style.transform = `translate(${x - 10}px, ${y - 10}px)`;
}

function tryCapture(x, y) {
  if (!isOn) return;
  const lensRect = lens.getBoundingClientRect();
  const centerX = lensRect.left + lensRect.width / 2;
  const centerY = lensRect.top + lensRect.height / 2;

  document.querySelectorAll('.orb').forEach(orb => {
    const rect = orb.getBoundingClientRect();
    const dx = (rect.left + rect.width/2) - centerX;
    const dy = (rect.top + rect.height/2) - centerY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const maxDist = lensRect.width / 2;
    const proximity = 1 - Math.min(dist / maxDist, 1);

    const isSpecial = orb.classList.contains('special-orb');
    const valid = (isSpecial && currentVision === 'heat') || (!isSpecial && currentVision === 'night');

    if (dist < maxDist && valid) {
      let orbScore = isSpecial ? 1000 : Math.floor(proximity * 100 * zoomLevel);
      let bonusTime = isSpecial ? 50 : Math.floor(orbScore / 20);
      score += orbScore;
      timeLeft += bonusTime;
      orbsCaptured++;
      updateScore();
      orb.remove();

      // Stop ticking if time boosted above 20
      if (timeLeft > 20) stopSounds();

      if (score >= 5000) endGame(true);
    }
  });
}

function updateScore() {
  scoreHud.textContent = `Score: ${score}`;
}

function startTimer() {
  timerStarted = true;
  updateFlipClock();
  gameInterval = setInterval(() => {
    timeLeft--;
    updateFlipClock();

    if (timeLeft <= 0) endGame(false);
    if (timeLeft <= 10 && !heartbeat) {
      stopSounds();
      heartbeat = true;
      heartbeatSound.loop = true;
      heartbeatSound.play();
    } else if (timeLeft <= 20 && !ticking) {
      tickSound.loop = true;
      tickSound.play();
      ticking = true;
    }
  }, 1000);
}

function stopSounds() {
  tickSound.pause();
  heartbeatSound.pause();
  ticking = false;
  heartbeat = false;
}

function updateFlipClock() {
  const minutes = Math.floor(timeLeft / 60);
  const seconds = timeLeft % 60;
  flipMinTen.textContent = Math.floor(minutes / 10);
  flipMinOne.textContent = minutes % 10;
  flipSecTen.textContent = Math.floor(seconds / 10);
  flipSecOne.textContent = seconds % 10;
}

function endGame(won = false) {
  clearInterval(gameInterval);
  stopSounds();
  document.getElementById("game-over").style.display = "flex";
  document.getElementById("end-title").textContent = won ? "🎉 You Win!" : "⏱️ Time's up!";
  document.getElementById("final-score").textContent = `Final Score: ${score}`;
  document.getElementById("orbs-counted").textContent = `Orbs Captured: ${orbsCaptured}`;
  document.getElementById("orbs").innerHTML = "";
}

function spawnOrbs() {
  const container = document.getElementById('orbs');
  container.innerHTML = "";
  const count = Math.floor(Math.random() * 2) + 2;

  for (let i = 0; i < count; i++) {
    const orb = document.createElement('div');
    const isSpecial = Math.random() < 0.1;
    orb.className = `orb ${isSpecial ? 'special-orb' : 'regular-orb'}`;
    orb.style.left = Math.random() * 90 + 'vw';
    orb.style.top = Math.random() * 80 + 'vh';
    container.appendChild(orb);
  }
  updateOrbsVisibility();
}

function updateOrbsVisibility() {
  document.querySelectorAll('.orb').forEach(orb => {
    const isSpecial = orb.classList.contains('special-orb');
    const visible = isSpecial ? currentVision === 'heat' : currentVision === 'night';
    orb.style.opacity = (isOn && visible) ? 1 : 0;
  });
}

function cycleZoom() {
  if (!isOn) return;
  zoomIndex = (zoomIndex + 1) % zoomSteps.length;
  zoomLevel = zoomSteps[zoomIndex];
  updateZoomVisual();
}

document.addEventListener('mousemove', e => moveLens(e.clientX, e.clientY));
document.addEventListener('click', e => tryCapture(e.clientX, e.clientY));
document.addEventListener('dblclick', () => isOn && cycleZoom());

document.addEventListener('touchstart', e => {
  const now = Date.now();
  if (now - lastTap < 300) {
    cycleZoom();
    lastTap = 0;
  } else {
    tryCapture(e.touches[0].clientX, e.touches[0].clientY);
    lastTap = now;
  }
});

setInterval(spawnOrbs, 8000);
spawnOrbs();
</script>
</body>
</html>
